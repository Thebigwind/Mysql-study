索引的出现其实就是为了提高数据查询的效率.



    脏读
    在一个事务中可以读到其他未提交的事务产生或变更的数据.
    PostgreSQL不支持read uncommitted事务隔离级别, 无法测试.
    不可重复读
    在一个事务中, 再次读取前面SQL读过的数据时, 可能出现读取到的数据和前面读取到的不一致的现象. (例如其他事务在此期间已提交的数据)
    使用read committed事务隔离级别测试
    幻像读
    在一个事务中, 再次执行同样的SQL, 得到的结果可能不一致.

事务特性

    原子性：作为一个整体要么都做，要么都不做；
    一致性：一个一致状态到另一个一致的状态；
    持久性：即使系统故障，仍保持一致状态通过预写式日志wal实现；
    隔离性：
    未提交的读取：脏读
    提交的读取:（默认级别），解决了脏读，会幻读（执行两次相同的查询，得到不同结果集）
    可重复读：复合select条件的结果集被锁定
    序列化：



哈希表是一种以键 - 值（key-value）存储数据的结构.
把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。


二叉搜索树

的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -> UserC -> UserF -> User2 这个路径得到。这个时间复杂度是 O(log(N))


二叉树是搜索效率最高的。 实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。因此使用多叉树。



InnoDB 的索引模型

InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。


每一个索引在 InnoDB 里面对应一棵 B+ 树。

主键索引的叶子节点存的是整行数据。非主键索引的叶子节点内容是主键的值。

    如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
    如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。


索引维护



select * from T where k between 3 and 5

回到主键索引树搜索的过程，我们称为回表

如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。


B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。


第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的




评论区：
1.
今天这个 alter table T engine=InnoDB 让我想到了我们线上的一个表, 记录日志用的, 会定期删除过早之前的数据. 最后这个表实际内容的大小才10G, 而他的索引却有30G. 在阿里云控制面板上看,就是占了40G空间. 这可花的是真金白银啊.
后来了解到是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放.
只能是重新建表才能重建索引.


作者回复: 😄确实例子都是血泪史，有些是我的血泪、有些是帮助人擦眼泪💧

也鼓励大家把平时碰到的问题提出来，大家一起未雨绸缪🤝



2.
老师，有这么个问题
一张表两个字段id, uname,id主键，uname普通索引
SELECT * FROM test_like WHERE uname LIKE 'j'/ 'j%' / '%j'/ '%j%'
模糊查询like后面四种写法都可以用到uname的普通索引

添加一个age字段
like后面的'%j'/ '%j%' 这两种情况用不到索引
把select * 改为 select id / select uname / select id,uname
like后面'j'/ 'j%' / '%j'/ '%j%' 这四种情况又都可以用到uname普通索引

建立uname,age的联合索引
模糊查询还是 LIKE 'j'/ 'j%' / '%j'/ '%j%'四种情况
其中select id / select uname / select id,uname
会用到uname的普通索引
select * 会用到uname,age的组合索引

看到好些文章会说模糊查询时以%开头不会用到索引，实践后发现结论跟文章描述的有出入。
看了索引的这两节内容对上面的各种情况有的可以解释通了，有的仍然有些模糊，想问下老师上面这些情况使用索引时为什么是这样的



作者回复: 好问题，这个是关于“用索引” 和 “用索引快速定位记录”的区别。

08 篇讲到这个问题了，周五关注一下。

简单回答：“用索引”有一种用法是 “顺序扫描索引”


3.

背景:
我们现在有一张表,每天生成300W数据, 然后每天用delete xx where id = x 这样的方式来删除.
不用truncate是因为DBA说truncate会重建自适应哈希索引,可能对整个库性能有影响.

操作:
这个表的主键id是递增的.
当我执行 explain select min(id) from t 时,是走的全表扫描.
而且我目前在从库执行这个sql,直接就卡住了.
执行 explain select max(id) from t 时, 结果是 Select tables optimized away
(目前最大id 5亿左右,实际数据量只有300W)

问题:
想问下老师
1. 为什么 min(id) 会是全表扫描呢? 是和存在大量的delete后未释放空间有关系吗?
2. 像这种业务场景,mysql怎么处理比较快速呢? 使用rename 表名有什么风险吗?



作者回复: 额你们DBA可能对自适应哈希索引（AHI）有误解…有其他同学也在评论中有提到AHI，我答疑文章会安排说明。

看你的描述，最好就是rename 重建一个新的，然后找低峰期删掉旧的表。

还有你这么说，应该id就是这个表的自增主键了，正常即使删除也不会全表扫描。不过我现在怀疑可能删的事务有没提交的，导致MySQL 没法回收复用旧空间。（这个可以简单从文件大小判断）

不过总之，rename +新建表，上面这个问题也自动解决了😓




3.总结：

    1、覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据
    2、最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符
    3、联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
    4、索引下推：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度

4.

老师，下面两条语句有什么区别，为什么都提倡使用2:

    1.select * from T where k in(1,2,3,4,5)
    2.select * from T where k between 1 and 5

    第一个要树搜素5次 ，第二个搜索一次

5.


