Oracle 数据库的默认隔离级别其实就是“读提交”


    mysql> show variables like 'transaction_isolation';
    
    +-----------------------+----------------+
    
    | Variable_name | Value |
    
    +-----------------------+----------------+
    
    | transaction_isolation | READ-COMMITTED |
    
    +-----------------------+----------------+


可重复读场景：

假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。
到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。
你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。


事务的启动方式

    1.显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。
    2.set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接

set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。

查询长事务：

    select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60



事务的可重复读的能力是怎么实现的？

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
    
    在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
    在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图;



InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。

    对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
    对于读提交，查询只承认在语句启动前就已经提交完成的数据；



